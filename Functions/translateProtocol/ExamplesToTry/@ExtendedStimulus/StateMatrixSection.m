% @ExtendedStimulus/StateMatrixSection
% BWB, August 2007

% [x, y] = StateMatrixSection(obj, action, x, y)
%
% HELP HERE
%
% PARAMETERS:
% -----------
%
% obj      Default object argument.
%
% action   One of:
%            'init'         To initialise the section
%
%            'next_trial'   To set up the state matrix for the next trial
%
%            'reinit'       Delete all of this section's GUIs and data,
%                           and reinit, at the same position on the same
%                           figure as the original section GUI was placed.
%
% x, y     Relevant to action = 'init'; they indicate the initial
%          position to place the GUI at, in the current figure window
%
% RETURNS:
% --------
%
% [x, y]   When action == 'init', returns x and y, pixel positions on
%          the current figure, updated after placing of this section's GUI. 
%


function  [] =  StateMatrixSection(obj, action)

global left1led;
global center1led;
global right1led;
global left1water;
global right1water;
%JPL - the above are supposed to have values from the settings file, but
%they are empty. where do they got populated, the dispatcher? hack for now

left1led =1;
center1led = 2;
right1led = 3;
left1water =4;
right1water = 5;

GetSoloFunctionArgs;


switch action
  case 'init', 
    
    feval(mfilename, obj, 'next_trial');

    
  case 'next_trial',

    sma = StateMachineAssembler('full_trial_structure');
    
    min_time=0.5E-3;  % This is close to the minumum time allowed for a state transition.
    
    
    
    % choose the correct sounds to play; if SoundsOn == 0, 
    % stimulus_id == 0
    k = SidesSection(obj, 'get_current_pair');
    try
        stimulus_id = SoundsOn*SoundManagerSection(obj, 'get_sound_id', sprintf('Sound%d', k));
        stimulus_dur = n_stimulus_cycles * ...
          SoundManagerSection(obj, 'get_sound_duration', sprintf('Sound%d', k));
    catch
        stimulus_id = 0;
        stimulus_dur = 1;
    end;
    if stimulus_id==0, stimulus_dur = 1; end;
    % ----------------------- SET UP CORRECT RESPONSES FOR L/R ------------------------------
    if SidesSection(obj, 'get_current_side') == 'l',
        LeftResponseState = 'left_reward';
        if PunishSideChoice == 1, 
            if SideChoicePunishmentType == 1,
                % punishment: temporary white noise
                RightResponseState = 'temporary_punishment';
            else
                % punishment: trial terminates
                RightResponseState = 'error_state1';
            end;
        else
            RightResponseState = 'current_state';
        end;
        
        % set up which side LED to turn on
        switch value(side_lights),
          case 'correct side only', side_led = left1led;
          case 'both sides on',     side_led = left1led+right1led;
          case 'both sides off',    side_led = 0;
          otherwise
            warning('ExtendedStimulus:UnknownSetting', 'Don''t know what to do with the side_lights setting');
        end;
        correct_side_led = left1led; %#ok<NASGU>
    else
        RightResponseState = 'right_reward';
        if PunishSideChoice == 1, 
            if SideChoicePunishmentType == 1,
                % punishment: temporary white noise    
                LeftResponseState = 'temporary_punishment';
            else
                % punishment: trial terminates
                LeftResponseState = 'error_state1';
            end;
        else
            LeftResponseState = 'current_state';
        end;
          
        % set up which side LED to turn on
        switch value(side_lights),
          case 'correct side only', side_led = right1led;
          case 'both sides on',     side_led = right1led+left1led;
          case 'both sides off',    side_led = 0;
          otherwise
            warning('ExtendedStimulus:UnknownSetting', 'Don''t know what to do with the side_lights setting');
        end;
        correct_side_led = right1led; %#ok<NASGU>
    end;
    
                             
    % ----------------------- SET UP N_CENTER_POKES ------------------------------
    if n_center_pokes == 0, 
        first_state = 'wait_for_spoke';
    else
        first_state = 'wait_for_cpoke';
    end;
    
    if PunishITIPokes == 1, iti_poke_state = 'iti_pun';
    else                    iti_poke_state = 'current_state';
    end;
    
     
    
    sma = add_state(sma, 'name', 'ITI', 'self_timer', ITI, ...
        'input_to_statechange', {'Tup', first_state; ...
                                 'Cin', iti_poke_state; ...
                                 'Lin', iti_poke_state; ...
                                 'Rin', iti_poke_state; ...
                                 });
                             

    sma = PunishInterface(obj, 'add_sma_states', 'ITIPun', sma, ...
        'name', 'iti_pun', ...
        'exitstate', 'iti');
                             
    % ----------------------- CENTER POKE ------------------------------
    if PunishCL1BadPokes == 1, poke_state = 'cl1_pun';
    else                       poke_state = 'current_state';
    end;
    
    sma = add_state(sma, 'name', 'WAIT_FOR_CPOKE', ...
        'output_actions', {'DOut', center1led}, ...
        'input_to_statechange', {'Cin', 'play_stimulus_sound'; ...
                                  'Lin', poke_state; ...
                                  'Rin', poke_state; ...
                                 });

    sma = PunishInterface(obj, 'add_sma_states', 'CenterLightPun', sma, ...
        'name', 'cl1_pun', ...
        'exitstate', 'wait_for_cpoke');


    % ----------------------- STIMULUS SETUP ------------------------------                        
    if StimTimeStart == 0,
      sma = add_scheduled_wave(sma, 'name', 'stop_stimulus_sound', 'preamble', stimulus_dur);
    else
      sma = add_scheduled_wave(sma, 'name', 'stop_stimulus_sound', 'preamble', max(FromAnswerPoke, min_time));
    end;
    
    if n_center_pokes < 2,
      if Center2SideGap  == 0, post_cpoke_state = 'wait_for_spoke';
      else                     post_cpoke_state = 'center_to_side_gap';
      end;
      if Center2SideGap2 == 0, post_c2sg_state  = 'wait_for_spoke';
      else                     post_c2sg_state  = 'center_to_side_gap2';
      end;
        
    else
      post_cpoke_state = 'center_to_center_gap';
    end;

    
    % first make sure the stimulus sound is off
    sma = add_state(sma, 'name', 'play_stimulus_sound', 'self_timer', min_time, ...
        'output_actions', {'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'Tup', 'current_state+1'});
    
    % then set it playing
    sma = add_state(sma, 'self_timer', min_time, ...
        'output_actions', {'SoundOut', stimulus_id}, ...
        'input_to_statechange', {'Tup', 'current_state+1'});
    
    % and trigger the scheduled wave that determines when to turn it off
    sma = add_state(sma, 'self_timer', min_time, ...
        'output_actions', {'SchedWaveTrig', '-stop_stimulus_sound'}, ...
        'input_to_statechange', {'Tup', 'current_state+1'});
    if StimTimeStart==0, % Only start the stimulus timer if we're in "FromStimStart'
      sma = add_state(sma, 'self_timer', min_time, ...
        'output_actions', {'SchedWaveTrig', 'stop_stimulus_sound'}, ...
        'input_to_statechange', {'Tup', post_cpoke_state});
    else
      sma = add_state(sma, 'self_timer', min_time, ...
        'input_to_statechange', {'Tup', post_cpoke_state});
    end;
    
    % ----------------------- CENTER TO CENTER GAP --------------------------

    if Center2SideGap == 0, post_cpoke2_state = 'wait_for_spoke';
    else                    post_cpoke2_state = 'center_to_side_gap';
    end;

    if Center2SideGap2 == 0, post_c2sg_state  = 'wait_for_spoke';
    else                     post_c2sg_state  = 'center_to_side_gap2';
    end;

    sma = add_state(sma, 'name', 'CENTER_TO_CENTER_GAP', ...
      'self_timer', max(Center2CenterGap, min_time), ...
      'input_to_statechange', {'Tup', 'wait_for_cpoke2'});
    sma = add_state(sma, 'name', 'WAIT_FOR_CPOKE2', ...
      'output_actions', {'DOut', center1led}, ...
      'input_to_statechange', {'Cin', 'current_state+1'});
    sma = add_state(sma, 'self_timer', min_time, ...
      'output_actions', {'DOut', center1led; ...
                         'SoundOut', -stimulus_id*StimOffAtCpoke2}, ...
      'input_to_statechange', {'Tup', post_cpoke2_state});
    
    
    % ----------------------- CENTER TO SIDE GAP --------------------------
    % this scheduled wave is the duration of one cycle repeat, after which
    % we turn on the side lights and allow a side choice
    sma = add_scheduled_wave(sma, 'name', 'c2s_gap', 'preamble', Center2SideGap+min_time);
    
    if PunishC2SCenterPokes == 1, center_poke_state = 'c2s_pun';
    else                          center_poke_state = 'current_state';
    end;
    
    if PunishC2SSidePokes == 1, side_poke_state = 'c2s_pun';
    else                        side_poke_state = 'current_state';
    end;
    
    % first trigger the scheduled wave that controls duration of c2s gap
    sma = add_state(sma, 'name', 'CENTER_TO_SIDE_GAP', ...
        'self_timer', min_time, ...
        'output_actions', {'SchedWaveTrig', '-c2s_gap'}, ...
        'input_to_statechange', {'Tup', 'current_state+1'});
    sma = add_state(sma, ...
        'self_timer', min_time, ...
        'output_actions', {'SchedWaveTrig', 'c2s_gap'}, ...
        'input_to_statechange', {'Tup', 'current_state+1'});

    % then wait in this gap until
    if isequal(first_pk_in_c2sgap, 'anything'),
      sma = add_state(sma, ...
        'input_to_statechange', {'c2s_gap_In', post_c2sg_state; ...
                                 'stop_stimulus_sound_In', 'current_state+1'; ...
                                 'Cin', center_poke_state; ...
                                 'Lin', side_poke_state; ...
                                 'Rin', side_poke_state; ...
                                });
      % duplicate of the previous state to turn off the stimulus sound
      sma = add_state(sma, ...
        'output_actions', {'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'c2s_gap_In', post_c2sg_state; ...
                                 'Cin', center_poke_state; ...
                                 'Lin', side_poke_state; ...
                                 'Rin', side_poke_state; ...
                                });
    else
      if isequal(first_pk_in_c2sgap, 'R'), goodpoke = 'Rin'; badpoke = 'Lin';
      else                                 goodpoke = 'Lin'; badpoke = 'Rin';
      end;

      % Waiting for the first poke:
      sma = add_state(sma, ...
        'input_to_statechange', {'c2s_gap_In', post_c2sg_state; ...
        'stop_stimulus_sound_In', 'current_state+1'; ...
        'Cin', center_poke_state; ...
        goodpoke, 'current_state+2'; ... % First poke was good
        badpoke,  'error_state1'; ...    % First poke was bad
        });
      % waiting for first poke, turning sound off:
      sma = add_state(sma, ...
        'output_actions', {'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'c2s_gap_In', post_c2sg_state; ...
        'Cin', center_poke_state; ...
        goodpoke, 'current_state+1'; ... % First poke was good
        badpoke,  'error_state1'; ...    % First poke was bad
        });
      % Done with first poke, just waiting for post_c2sgap_state:
      sma = add_state(sma, ...
        'input_to_statechange', {'c2s_gap_In', post_c2sg_state; ...
        'stop_stimulus_sound_In', 'current_state+1'; ...
        'Cin', center_poke_state; ...
        });
      % Done with first poke, stopping sound and waiting for post_c2sgap_state:
      sma = add_state(sma, ...
        'output_actions', {'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'c2s_gap_In', post_c2sg_state; ...
        'Cin', center_poke_state; ...
        });
    end;
                            
    % c2s punishment states: first turn off the stimulus sound
    sma = add_state(sma, 'name', 'c2s_pun', ...
        'self_timer', min_time, ...
        'output_actions', {'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'Tup', 'c2s_pun2'});
    % then add punishment states
    sma = PunishInterface(obj, 'add_sma_states', 'C2SPun', sma, ...
        'name', 'c2s_pun2', ...
        'exitstate', 'play_stimulus_sound');


    % ----------------------- CENTER 2 SIDE GAP 2 --------------------------
    %  A gap that has no punishments, either for side pokes or center pokes,
    % it is just a temporal gap
    
    sma = add_scheduled_wave(sma, 'name', 'c2s_gap2', 'preamble', Center2SideGap2+min_time);
    
    
    % first trigger the scheduled wave that controls duration of c2s gap 2
    sma = add_state(sma, 'name', 'CENTER_TO_SIDE_GAP2', ...
        'self_timer', min_time, ...
        'output_actions', {'SchedWaveTrig', '-c2s_gap2'}, ...
        'input_to_statechange', {'Tup', 'current_state+1'});
    sma = add_state(sma, ...
        'self_timer', min_time, ...
        'output_actions', {'SchedWaveTrig', 'c2s_gap2'}, ...
        'input_to_statechange', {'Tup', 'current_state+1'});

    % then wait in this gap until time over
    sma = add_state(sma, ...
      'input_to_statechange', {'c2s_gap2_In', 'wait_for_spoke'; ...
                               'stop_stimulus_sound_In', 'current_state+1'; ...
                              });
    % duplicate of the previous state to turn off the stimulus sound
    sma = add_state(sma, ...
      'output_actions', {'SoundOut', -stimulus_id}, ...
      'input_to_statechange', {'c2s_gap2_In', 'wait_for_spoke'});


    % ----------------------- SIDE POKES --------------------------
    
    sma = add_state(sma, 'name', 'wait_for_spoke', ...
        'output_actions', {'DOut', side_led}, ...
        'input_to_statechange', {'Lin', LeftResponseState; ...
                                 'Rin', RightResponseState; ...
                                 'stop_stimulus_sound_In', 'current_state+1'; ...
                                });
    
    sma = add_state(sma, ...
        'output_actions', {'DOut', side_led; ...
                           'SoundOut', -stimulus_id; ...
                          }, ...
        'input_to_statechange', {'Lin', LeftResponseState; ...
                                 'Rin', RightResponseState; ...
                                });
                             

    % ----------------------- ERROR STATES --------------------------------
    sma = add_state(sma, 'name', 'error_state1', ...
        'self_timer', min_time, ...
        'output_actions', {'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'Tup', 'error_state'});
    
    sma = PunishInterface(obj, 'add_sma_states', 'ErrorPun', sma, ...
        'name', 'error_state', ...
        'exitstate', 'clean_up_state');
   
    
    sma = PunishInterface(obj, 'add_sma_states', 'TimeOutPun', sma, ...
        'name', 'temporary_punishment', ...
        'exitstate', 'wait_for_spoke');
    

    % ----------------------- REWARD STATES -------------------------------
    
    % NOTE: at this implementation, if the stimulus sound loop is still playing by
    % the time the rat gets to one of the reward states, it will stay
    % on until the end of the hit states
    % the led at the correct side choice stays on until the trial ends
    
    [LeftWValveTime RightWValveTime] = WaterValvesSection(obj, 'get_water_times', hit_streak);
    try
        k = SidesSection(obj, 'get_current_pair');
        wtr_ml = StimulusSection(obj, 'get', k, 'wtr_ml');
    catch
        wtr_ml = 1;
    end;
    
    sma = add_scheduled_wave(sma, 'name', 'water_wait', 'preamble', max(water_wait, min_time));
    sma = add_scheduled_wave(sma, 'name', 'left_water_valve',  'preamble', max(LeftWValveTime*wtr_ml,  min_time));
    sma = add_scheduled_wave(sma, 'name', 'right_water_valve', 'preamble', max(RightWValveTime*wtr_ml, min_time));
    
    if StimTimeStart == 0,
      sma = add_state(sma, 'name', 'LEFT_REWARD', ...
        'output_actions', {'DOut', left1led*water_wait_lights; 'SchedWaveTrig', 'water_wait'}, ...
        'input_to_statechange', {'water_wait_In', 'current_state+2' ; ...
                                 'stop_stimulus_sound_In', 'current_state+1'});
    else % We're in FromAnswerPoke, start stimulus timer now
      sma = add_state(sma, 'name', 'LEFT_REWARD', ...
        'output_actions', {'DOut', left1led*water_wait_lights; 
                           'SchedWaveTrig', 'water_wait+stop_stimulus_sound'}, ...
        'input_to_statechange', {'water_wait_In', 'current_state+2' ; ...
                                 'stop_stimulus_sound_In', 'current_state+1'});
    end;
    sma = add_state(sma, ...
        'output_actions', {'DOut', left1led*water_wait_lights ; 'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'water_wait_In', 'current_state+1'});
    
    sma = add_state(sma, ...
        'output_actions', {'DOut', left1water+left1led*water_wait_lights; ...
                          'SchedWaveTrig', 'left_water_valve'}, ...
        'input_to_statechange', {'left_water_valve_In',    'hit_state' ; ...
                                 'stop_stimulus_sound_In', 'current_state+1'});
    sma = add_state(sma, ...
        'output_actions', {'DOut', left1water+left1led*water_wait_lights; ...
                          'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'left_water_valve_In',    'hit_state'});

      
    if StimTimeStart == 0,
      sma = add_state(sma, 'name', 'RIGHT_REWARD', ...
        'output_actions', {'DOut', right1led*water_wait_lights; 'SchedWaveTrig', 'water_wait'}, ...
        'input_to_statechange', {'water_wait_In', 'current_state+2' ; ...
                                 'stop_stimulus_sound_In', 'current_state+1'});
    else % We're in FromAnswerPoke, start stimulus timer now
      sma = add_state(sma, 'name', 'RIGHT_REWARD', ...
        'output_actions', {'DOut', right1led*water_wait_lights; 
                           'SchedWaveTrig', 'water_wait+stop_stimulus_sound'}, ...
        'input_to_statechange', {'water_wait_In', 'current_state+2' ; ...
                                 'stop_stimulus_sound_In', 'current_state+1'});
    end;
    sma = add_state(sma, ...
        'output_actions', {'DOut', right1led*water_wait_lights ; 'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'water_wait_In', 'current_state+1'});
    
    sma = add_state(sma, ...
        'output_actions', {'DOut', right1water+right1led*water_wait_lights; ...
                          'SchedWaveTrig', 'right_water_valve'}, ...
        'input_to_statechange', {'right_water_valve_In',    'hit_state' ; ...
                                 'stop_stimulus_sound_In', 'current_state+1'});
    sma = add_state(sma, ...
        'output_actions', {'DOut', right1water+right1led*water_wait_lights; ...
                          'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'right_water_valve_In',    'hit_state'});
      
    
    if SoftDrinkTime == 1, 
      post_hit_state_in  = 'soft_drink_state';
      post_hit_state_out = 'soft_drink_state+1';
    else
      post_hit_state_in  = 'drink_state';
      post_hit_state_out = 'drink_state';
    end;
    
    switch SidesSection(obj, 'get_current_side'),
      case 'l', InAction = 'Lin'; OutAction = 'Lout'; OtherSidePokeIn = 'Rin';
      case 'r', InAction = 'Rin'; OutAction = 'Rout'; OtherSidePokeIn = 'Lin';
      otherwise
        error('EXTENDEDSTIMULUS:Invalid', 'Don''t know how to deal with current_side "%s"', SidesSection(obj, 'get_current_side'));
    end;


    sma = add_scheduled_wave(sma, 'name', 'hitstatetimer', 'preamble', DrinkTime);
   
    % allows rat to continue drinking for the time allotted in
    % PenaltySection_DrinkTime
    % First we just trigger the hit_state_timer:
    sma = add_state(sma, 'name', 'HIT_STATE', 'self_timer', min_time, ...
      'output_actions', {'SchedWaveTrig', 'hitstatetimer'}, ...
      'input_to_statechange', {'Tup', 'current_state+1'});
    % Then we toggle back and forth between being in or out of the drink
    % port:
    sma = add_state(sma, 'input_to_statechange', ...
      {'hitstatetimer_In', post_hit_state_in ; ...
      'stop_stimulus_sound_In', 'current_state+2' ; ...
      OutAction, 'current_state+1'});
    sma = add_state(sma, 'input_to_statechange', ...
      {'hitstatetimer_In', post_hit_state_out; ...
      'stop_stimulus_sound_In', 'current_state+2' ; ...
      InAction, 'current_state-1'});   
    % Now duplicates to turn stimulus sound off:
    sma = add_state(sma, 'self_timer', min_time, 'input_to_statechange', ...
      {'Tup', 'current_state-2' ; ...
      'hitstatetimer_In', post_hit_state_in ; ...
      OutAction, 'current_state-1'}, ...
      'output_actions', {'SoundOut' -stimulus_id});
    sma = add_state(sma, 'self_timer', min_time, 'input_to_statechange', ...
      {'Tup', 'current_state-2' ; ...
      'hitstatetimer_In', post_hit_state_out ; ...
      InAction, 'current_state-3'}, ...
      'output_actions', {'SoundOut' -stimulus_id});
    
                                     
    % timed drinking states:
    if WarnDur > 0,                     post_drink_state = 'warning';
    elseif WarnDur==0 && DangerDur > 0, post_drink_state = 'danger';
    elseif WarnDur==0 && DangerDur==0,  post_drink_state = 'clean_up_state';
    end;
    if DangerDur > 0,                   post_warning_state = 'danger';
    else                                post_warning_state = 'clean_up_state';
    end;   
    
    warn_id   = SoundManagerSection(obj, 'get_sound_id', 'WarningSound');
    danger_id = SoundManagerSection(obj, 'get_sound_id', 'DangerSound');

    sma = add_state(sma, 'name', 'DRINK_STATE', 'self_timer', min_time, ...
        'input_to_statechange', {'Tup', post_drink_state});
    sma = add_state(sma, 'name', 'WARNING', 'self_timer', min_time, ...
        'output_actions', {'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'Tup', 'current_state+1'});
    sma = add_state(sma, 'self_timer', WarnDur, ...
        'input_to_statechange', {'Tup', post_warning_state}, ...
        'output_actions', {'SoundOut', warn_id});
    sma = add_state(sma, 'name', 'DANGER',  'self_timer', DangerDur, ...
        'output_actions', {'SoundOut', danger_id}, ...
        'input_to_statechange', {'Tup', 'clean_up_state', ...
                                 'Lin', 'current_state+1', ...
                                 'Cin', 'current_state+1', ...
                                 'Rin', 'current_state+1'});
    sma = add_state(sma, 'self_timer', min_time, ...
        'output_actions', {'SoundOut', -danger_id}, ...
        'input_to_statechange', {'Tup', 'current_state+1'});
    sma = PunishInterface(obj, 'add_sma_states', 'PostDrinkPun', sma, 'name', 'mypun', ...
        'exitstate', 'danger');    
    
    
    
    % soft drink states:
    % as long as the rat is licking every .25 sec or so, remain in one of
    % the soft drink states
    % if the rat stops licking for more than SoftDrinkGrace sec, consider him done
    % drinking and move on
    % (if the stimulus is still on at this point, keep it on for as long as
    % the rat is drinking)
    %
    % NOTE: this is _NOT_ robust and does not handle the case when the rat
    % enters soft_drink_state in a poke and does not come back out for more
    % than SoftDrinkGrace seconds!  
    % There's no easy way to solve this and until we can
    % get information on whether the snout is in/out, I'm going to leave
    % this version, which works most of the time when the rat drinks
    % with a series of rapid in/out licks.  (See quadsamp3 for a more
    % complicated version of soft drink time.)
    % BWB, 31 Aug 2007
    %
    
    if WD_in_sdt==1, post_softdt = post_drink_state;
    else             post_softdt = 'clean_up_state';
    end;    
    
    
    if SoftDrinkCap > DrinkTime, softdrinktimer = SoftDrinkCap-DrinkTime+min_time;
    else                         softdrinktimer = min_time;
    end;
    
    sma = add_scheduled_wave(sma, 'name', 'softdrinktimer', 'preamble', softdrinktimer);
    sma = add_scheduled_wave(sma, 'name', 'sd_grace',       'preamble', max(SoftDrinkGrace, 3*min_time));

    % Entry to soft_drink_state_in:
    sma = add_state(sma, 'name', 'SOFT_DRINK_STATE', ...
        'self_timer', min_time, ...
        'output_actions', {'SchedWaveTrig', 'softdrinktimer'}, ...
        'input_to_statechange', {'Tup', 'current_state+2'});

    % Entry to soft_drink_state_out:
    sma = add_state(sma, ...
        'self_timer', min_time, ...
        'output_actions', {'SchedWaveTrig', 'softdrinktimer'}, ...
        'input_to_statechange', {'Tup', 'current_state+2'});

    sma = add_state(sma, 'output_actions', {'SchedWaveTrig', '-sd_grace'}, ...
      'input_to_statechange', {'softdrinktimer_In',      post_drink_state, ...
                               OutAction,                'current_state+1', ...
                               'Cin',                    post_softdt, ...
                               OtherSidePokeIn,          post_softdt, ... 
                               'stop_stimulus_sound_In', 'current_state+3', ...
                               });
    sma = add_state(sma, 'self_timer', min_time, 'output_actions', {'SchedWaveTrig', 'sd_grace'}, ...
      'input_to_statechange', {'Tup',                    'current_state+1' ; ...
                               'stop_stimulus_sound_In', 'current_state+3'});     
    sma = add_state(sma, ...
      'input_to_statechange', {'softdrinktimer_In', post_drink_state, ...     
                               InAction,            'current_state-2', ...
                               'Cin',               post_softdt, ...
                               OtherSidePokeIn,     post_softdt, ...         
                               'sd_grace_In',       post_softdt, ... 
                               'stop_stimulus_sound_In', 'current_state+2'});

    % Duplication of above two states to deal with stop_stimulus_sound_In:
    sma = add_state(sma, 'self_timer', min_time, 'output_actions', {'SoundOut', -stimulus_id}, ...
      'input_to_statechange', {'softdrinktimer_In',      post_drink_state, ...
                               OutAction,                'current_state-2', ...
                               'Cin',                    post_softdt, ...
                               OtherSidePokeIn,          post_softdt, ... 
                               'Tup',                    'current_state-3', ...
                               });
    sma = add_state(sma, 'self_timer', min_time, 'output_actions', {'SoundOut', -stimulus_id}, ...
      'input_to_statechange', {'softdrinktimer_In', post_drink_state, ...     
                               InAction,            'current_state-4', ...
                               'Cin',               post_softdt, ...
                               OtherSidePokeIn,     post_softdt, ... 
                               'sd_grace_In',       post_softdt, ...
                               'Tup',               'current_state-2'});

                             
                             
      
    % clean up any remaining sounds still playing, then jump to next
    % trial
    sma = add_state(sma, 'name', 'CLEAN_UP_STATE', ...
        'self_timer', min_time, ...
        'output_actions', {'SoundOut', -stimulus_id}, ...
        'input_to_statechange', {'Tup', 'current_state+1'});
    
    sma = add_state(sma,  ...
        'self_timer', min_time, ...
        'output_actions', {'SoundOut', -danger_id}, ...
        'input_to_statechange', {'Tup', 'check_next_trial_ready'});    
                            
    % add states to the 'prepare_next_trial' states:
    dispatcher('send_assembler', sma, {'hit_state', 'error_state'});
    
  case 'reinit',

    % Delete all SoloParamHandles who belong to this object and whose
    % fullname starts with the name of this mfile:
    delete_sphandle('owner', ['^@' class(obj) '$'], ...
      'fullname', ['^' mfilename]);

    % Reinitialise at the original GUI position and figure:
    feval(mfilename, obj, 'init');
    
end;